// Copyright 2020 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
/*
 * generated from files in sound-open-firmware-private/src/include:
 * kernel/header.h
 * ipc/control.h
 */

/* automatically generated by rust-bindgen 0.63.0 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[doc = " \\brief Header for all non IPC ABI data.\n\n Identifies data type, size and ABI.\n Data header used for all component data structures and binary blobs sent to\n firmware as runtime data. This data is typically sent by userspace\n applications and tunnelled through any OS kernel (via binary kcontrol on\n Linux) to the firmware."]
#[repr(C, packed)]
pub struct sof_abi_hdr {
    #[doc = "< 'S', 'O', 'F', '\\0'"]
    pub magic: u32,
    #[doc = "< component specific type"]
    pub type_: u32,
    #[doc = "< size in bytes of data excl. this struct"]
    pub size: u32,
    #[doc = "< SOF ABI version"]
    pub abi: u32,
    #[doc = "< reserved for future use"]
    pub reserved: [u32; 4usize],
    #[doc = "< Component data - opaque to core"]
    pub data: __IncompleteArrayField<u32>,
}
#[test]
fn bindgen_test_layout_sof_abi_hdr() {
    const UNINIT: ::std::mem::MaybeUninit<sof_abi_hdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sof_abi_hdr>(),
        32usize,
        concat!("Size of: ", stringify!(sof_abi_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<sof_abi_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(sof_abi_hdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abi) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(abi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "< maps to ALSA volume style controls"]
pub const sof_ipc_ctrl_cmd_SOF_CTRL_CMD_VOLUME: sof_ipc_ctrl_cmd = 0;
#[doc = "< maps to ALSA enum style controls"]
pub const sof_ipc_ctrl_cmd_SOF_CTRL_CMD_ENUM: sof_ipc_ctrl_cmd = 1;
#[doc = "< maps to ALSA switch style controls"]
pub const sof_ipc_ctrl_cmd_SOF_CTRL_CMD_SWITCH: sof_ipc_ctrl_cmd = 2;
#[doc = "< maps to ALSA binary style controls"]
pub const sof_ipc_ctrl_cmd_SOF_CTRL_CMD_BINARY: sof_ipc_ctrl_cmd = 3;
#[doc = " Control command type."]
pub type sof_ipc_ctrl_cmd = ::std::os::raw::c_uint;
